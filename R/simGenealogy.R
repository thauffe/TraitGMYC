#' @title Simulate genealogies
#'
#' @description This function simulates genealogies
#' using the multispecies coalescence approach of Fujisawa and Barraclough (2013).
#'
#' @param Species The species tree within the gene trees should be simulated
#' for Scenarios B-G. In case of Scenario A the number of species.
#' If Nsim > 1 there should be multiphylo
#' @param Scenario Scenario of Fujisawa and Barraclough (2013)
#' * A Null model assuming a neutral coalescent process in a single population
#' * B Diversification (coalescence within a species tree)
#' * D Fluctuating population sizes
#' @param Ind Individuals per species.
#' Either a vector of length 1 (i.e. same number of individuals per species) or
#' of the same length as Ntip(SpeciesTree)
#' @param PopSize Population size \ifelse{html}{\out{<i>N</i><sub>e</sub>}}{\eqn{Ne}}.
#' Assumed to be the same for each species but can vary over time in scenario D.
#' Either a vector of length 1 or of the same length as Nsim.
#' @param Nsim Number of simulated genealogies
#' @param Scale Scale depth of genealogy to this value (e.g. 1)
#' @md
#'
#' @details Scenarios C1 and C2 of incomplete taxon sampling or
#' non-zero rate of species extinction from Fujisawa and Barraclough (2013) are
#' possible to simulate by using a different species tree (see examples).
#' Moreover, the species tree could be also generated by the protracted birth-death
#' process to mirror the genealogy simulation of Sukumaran and Knowles (2017).
#'
#' @author Torsten Hauffe but most of the code was forked
#' from Fujisawa and Barraclough (2013)
#'
#' @return A genealogy, which for scenarios B-G is simulated
#' within the provided species tree.
#'
#' @references Fujisawa, T. and T. Barraclough (2013): Delimiting species using
#' single-locus data and the Generalized Mixed Yule Coalescent approach:
#' a revised method and evaluation on simulated data sets.
#' Systematic Biology 62(5), 707-724.
#'
#' @export simGenealogy
#'
#'@examples
#' # Scenario A
#' GeneTree <- simGenealogy(Species = 30,
#'                          Scenario = "A",
#'                          Ind = 5,
#'                          PopSize = 10000)
#' plot(GeneTree, cex = 0.4)
#' # Scenario B
#' SpeciesTree <- pbtree(b = 0.27, n = 30)
#' GeneTree <- simGenealogy(Species = SpeciesTree,
#'                          Scenario = "B",
#'                          Ind = 5,
#'                          PopSize = 10000)
#' plot(GeneTree, cex = 0.4)
#'
#' # Scenario C1
#' FullTree <- pbtree(b = 0.27, n = 50)
#' SpeciesTree <- drop.tip(FullTree, sample(FullTree$tip.labels, 20))
#' GeneTree <- simGenealogy(Species = SpeciesTree,
#'                          Scenario = "C1",
#'                          Ind = 5,
#'                          PopSize = 10000)
#' plot(GeneTree, cex = 0.4)
#' # Scenario C2
simGenealogy <- function (Species = 30,
                          Scenario = "A",
                          Ind = 5,
                          PopSize = 10000,
                          Nsim = 1,
                          Scale = NULL) {
  if (class(Species) == "numeric") {
    TipsSpecies <- Species[[1]]
  }
  else {
    Species <- as.multiPhylo(Species)
    TipsSpecies <- Ntip(Species[[1]])
  }
  LenInd <- length(Ind)
  if (LenInd != 1 && LenInd != TipsSpecies) {
    stop("Number of individuals should be the same for all species or\na vector with a length equal to the number of species")
  }
  Ind <- rep(Ind, (TipsSpecies * (LenInd != TipsSpecies) + (LenInd == TipsSpecies)) )
  N <- sum(Ind)
  if (length(PopSize) == 1) {
    PopSize <- rep(PopSize, Nsim)
  }
  CoalTree <- vector(mode = "list", length = length(Species))
  if (Scenario == "A") {
    MsOut <- ms(N, Nsim, opts = "-T")
    CoalTree <- read.tree(text = MsOut)
  }
  if (Scenario %in% c("B", "C1", "C2")) {
    for (i in 1:Nsim) {
      Tree <- Species[[i]]
      TreeDepth <- max(branching.times(Tree))
      # Fujisawa & Barraclough scale to depth of 10000000 generations ~ 10 Ma
      # Scale to million years
      Tree$edge.length <- Tree$edge.length * 1e6
      Tree$edge.length <- Tree$edge.length/(4 * PopSize)
      NumNode <- Tree$Nnode
      des <- matrix(NA, nrow = NumNode, ncol = 3)
      des[, 1] <- branching.times(Tree)
      for (j in 1:NumNode) {
        des[j, 2:3] <- Tree$edge[, 2][Tree$edge[, 1] == j + TipsSpecies]
      }
      new.num <- rep(NA, NumNode)
      for (j in NumNode:1) {
        if (des[j, 2] > TipsSpecies) {
          des[j, 2] <- new.num[des[j, 2] - TipsSpecies]
        }
        if (des[j, 3] > TipsSpecies) {
          des[j, 3] <- new.num[des[j, 3] - TipsSpecies]
        }
        new.num[j] <- min(des[j, 2:3])
        des[j, 2:3] <- sort(des[j, 2:3], decreasing = TRUE)
      }
      # Fujisawa & Barraclough without Theta: -t 4*Ne*mu
      Opts <- paste("-I", TipsSpecies, collapse = " ")
      Opts <- paste(Opts, paste(Ind, collapse = " "), collapse = " ")
      Ej <- paste(apply(des, 1, function(x) paste("-ej", paste(x, collapse = " "), collapse = " ")),
                  collapse = " ")
      Opts <- paste(Opts, Ej, "-T", collapse = " ")
      MsOut <- ms(N, 1, opts = Opts)
      CoalTree[[i]] <- read.tree(text = MsOut)
      CoalTree[[i]]$edge.length <- CoalTree[[i]]$edge.length / max(branching.times(CoalTree[[i]])) * TreeDepth
    }
  }
  NewTipLabels <- sapply(1:TipsSpecies,
                         function(x) paste0(paste0("Tip", x, "."), 1:Ind[x]),
                         simplify = FALSE)
  NewTipLabels <- unlist(NewTipLabels)
  for (i in 1:length(CoalTree)) {
    Ord <- as.numeric(unlist(lapply(strsplit(CoalTree[[i]]$tip.label, "s"),
                                    function(x) x[2])))
    CoalTree[[i]]$tip.label <- NewTipLabels[Ord]
    if (!is.null(Scale)) {
      CoalTree[[i]]$edge.length <- CoalTree[[i]]$edge.length / max(branching.times(CoalTree[[i]])) * Scale
    }
  }
  class(CoalTree) <- "multiPhylo"
  if (length(CoalTree) == 1) {
    CoalTree <- CoalTree[[1]]
  }
  return(CoalTree)
}
